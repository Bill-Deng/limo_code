// *********************************************************
//
// File autogenerated for the viso_feature_tracking_ros_tool package
// by the rosinterface_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <stdlib.h>
#include <string>
#include <limits>
#include <memory>
#include <ros/param.h>
#include <ros/node_handle.h>
#include <rosinterface_handler/console_bridge_compatibility.hpp>
#include <rosinterface_handler/utilities.hpp>
#ifdef MESSAGE_FILTERS_FOUND
#include <message_filters/subscriber.h>

#else

#endif
#ifdef DYNAMIC_RECONFIGURE_FOUND
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wparentheses"
#include <viso_feature_tracking_ros_tool/FeatureTrackingContourRoiConfig.h>
#pragma GCC diagnostic pop
#else
struct FeatureTrackingContourRoiConfig{};
#endif


namespace viso_feature_tracking_ros_tool {

/// \brief Parameter struct generated by rosinterface_handler
struct FeatureTrackingContourRoiInterface {

  using Config = FeatureTrackingContourRoiConfig;
#ifdef MESSAGE_FILTERS_FOUND
  template<typename T>
  using Subscriber = message_filters::Subscriber<T>;
  template<typename T>
  using SubscriberPtr = std::shared_ptr<Subscriber<T>>;
#endif
#ifdef IF_HANDLER_DIAGNOSTICS_INCLUDED
  template<typename T, typename BaseT = message_filters::Subscriber<T>>
  using DiagSubscriber = rosinterface_handler::DiagnosedSubscriber<T, BaseT>;
  template<typename T, typename BaseT = message_filters::Subscriber<T>>
  using DiagSubscriberPtr = std::shared_ptr<DiagSubscriber<T, BaseT>>;
  template<typename T>
  using DiagPublisher = rosinterface_handler::DiagnosedPublisher<T>;
#endif

  FeatureTrackingContourRoiInterface(const ros::NodeHandle& private_node_handle)
  : globalNamespace_{"/"},
    publicNamespace_{rosinterface_handler::getParentNamespace(private_node_handle) + "/"},
    privateNamespace_{private_node_handle.getNamespace() + "/"},
    nodeName_{rosinterface_handler::getNodeName(private_node_handle)},
    privateNodeHandle_{private_node_handle} {}

  /// \brief Get values from parameter server
  ///
  /// Will fail if a value can not be found and no default value is given.
  void fromParamServer(){
    bool success = true;
    success &= rosinterface_handler::getParam(privateNamespace_ + "verbosity", verbosity, std::string{"info"});
    rosinterface_handler::setLoggerLevel(privateNodeHandle_, "verbosity", nodeName());
    success &= rosinterface_handler::getParam(privateNamespace_ + "msg_queue_size", msg_queue_size, int{5});
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_debug");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_info");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_warning");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_error");
    rosinterface_handler::testConstParam(privateNamespace_ + "verbosity_fatal");
    success &= rosinterface_handler::getParam(privateNamespace_ + "subscriber_image", subscriber_image, std::string{"in_topic_image"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "subscriber_contour", subscriber_contour, std::string{"in_topic_contour"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "publisher_msg_name", publisher_msg_name, std::string{"out_topic"});
    success &= rosinterface_handler::getParam(privateNamespace_ + "scale_factor", scale_factor, double{1.0});
    success &= rosinterface_handler::getParam(privateNamespace_ + "blur_size", blur_size, int{3});
    success &= rosinterface_handler::getParam(privateNamespace_ + "blur_sigma", blur_sigma, double{0.8});
    success &= rosinterface_handler::getParam(privateNamespace_ + "nms_n", nms_n, int{3});
    success &= rosinterface_handler::getParam(privateNamespace_ + "nms_tau", nms_tau, int{50});
    success &= rosinterface_handler::getParam(privateNamespace_ + "match_binsize", match_binsize, int{50});
    success &= rosinterface_handler::getParam(privateNamespace_ + "match_radius", match_radius, int{200});
    success &= rosinterface_handler::getParam(privateNamespace_ + "match_disp_tolerance", match_disp_tolerance, int{2});
    success &= rosinterface_handler::getParam(privateNamespace_ + "outlier_flow_tolerance", outlier_flow_tolerance, int{5});
    success &= rosinterface_handler::getParam(privateNamespace_ + "outlier_disp_tolerance", outlier_disp_tolerance, int{5});
    success &= rosinterface_handler::getParam(privateNamespace_ + "multi_stage", multi_stage, int{1});
    success &= rosinterface_handler::getParam(privateNamespace_ + "half_resolution", half_resolution, int{1});
    success &= rosinterface_handler::getParam(privateNamespace_ + "method", method, int{0});
    success &= rosinterface_handler::getParam(privateNamespace_ + "max_tracklength", max_tracklength, int{10});



    rosinterface_handler::testMin<int>(privateNamespace_ + "msg_queue_size", msg_queue_size, 1);
    rosinterface_handler::testMin<double>(privateNamespace_ + "scale_factor", scale_factor, 0.0);
    rosinterface_handler::testMax<double>(privateNamespace_ + "scale_factor", scale_factor, 1.0);
    rosinterface_handler::testMin<int>(privateNamespace_ + "blur_size", blur_size, 1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "blur_size", blur_size, 21);
    rosinterface_handler::testMin<double>(privateNamespace_ + "blur_sigma", blur_sigma, 1e-05);
    rosinterface_handler::testMax<double>(privateNamespace_ + "blur_sigma", blur_sigma, 10.0);
    rosinterface_handler::testMin<int>(privateNamespace_ + "nms_n", nms_n, 1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "nms_n", nms_n, 15);
    rosinterface_handler::testMin<int>(privateNamespace_ + "nms_tau", nms_tau, 1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "nms_tau", nms_tau, 500);
    rosinterface_handler::testMin<int>(privateNamespace_ + "match_binsize", match_binsize, 1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "match_binsize", match_binsize, 1500);
    rosinterface_handler::testMin<int>(privateNamespace_ + "match_radius", match_radius, 1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "match_radius", match_radius, 1500);
    rosinterface_handler::testMin<int>(privateNamespace_ + "match_disp_tolerance", match_disp_tolerance, 1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "match_disp_tolerance", match_disp_tolerance, 21);
    rosinterface_handler::testMin<int>(privateNamespace_ + "outlier_flow_tolerance", outlier_flow_tolerance, 1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "outlier_flow_tolerance", outlier_flow_tolerance, 50);
    rosinterface_handler::testMin<int>(privateNamespace_ + "outlier_disp_tolerance", outlier_disp_tolerance, 1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "outlier_disp_tolerance", outlier_disp_tolerance, 50);
    rosinterface_handler::testMin<int>(privateNamespace_ + "multi_stage", multi_stage, 0);
    rosinterface_handler::testMax<int>(privateNamespace_ + "multi_stage", multi_stage, 1);
    rosinterface_handler::testMin<int>(privateNamespace_ + "half_resolution", half_resolution, 0);
    rosinterface_handler::testMax<int>(privateNamespace_ + "half_resolution", half_resolution, 1);
    rosinterface_handler::testMin<int>(privateNamespace_ + "method", method, 0);
    rosinterface_handler::testMax<int>(privateNamespace_ + "method", method, 2);
    rosinterface_handler::testMin<int>(privateNamespace_ + "max_tracklength", max_tracklength, 1);
    rosinterface_handler::testMax<int>(privateNamespace_ + "max_tracklength", max_tracklength, 100);
    if(!success){
      missingParamsWarning();
      rosinterface_handler::exit("RosinterfaceHandler: GetParam could net retrieve parameter.");
    }
    ROS_DEBUG_STREAM(*this);
  }

  /// \brief Set parameters on ROS parameter server.
  void toParamServer(){
    rosinterface_handler::setParam(privateNamespace_ + "verbosity",verbosity);
    rosinterface_handler::setParam(privateNamespace_ + "msg_queue_size",msg_queue_size);
    rosinterface_handler::setParam(privateNamespace_ + "subscriber_image",subscriber_image);
    rosinterface_handler::setParam(privateNamespace_ + "subscriber_contour",subscriber_contour);
    rosinterface_handler::setParam(privateNamespace_ + "publisher_msg_name",publisher_msg_name);
    rosinterface_handler::setParam(privateNamespace_ + "scale_factor",scale_factor);
    rosinterface_handler::setParam(privateNamespace_ + "blur_size",blur_size);
    rosinterface_handler::setParam(privateNamespace_ + "blur_sigma",blur_sigma);
    rosinterface_handler::setParam(privateNamespace_ + "nms_n",nms_n);
    rosinterface_handler::setParam(privateNamespace_ + "nms_tau",nms_tau);
    rosinterface_handler::setParam(privateNamespace_ + "match_binsize",match_binsize);
    rosinterface_handler::setParam(privateNamespace_ + "match_radius",match_radius);
    rosinterface_handler::setParam(privateNamespace_ + "match_disp_tolerance",match_disp_tolerance);
    rosinterface_handler::setParam(privateNamespace_ + "outlier_flow_tolerance",outlier_flow_tolerance);
    rosinterface_handler::setParam(privateNamespace_ + "outlier_disp_tolerance",outlier_disp_tolerance);
    rosinterface_handler::setParam(privateNamespace_ + "multi_stage",multi_stage);
    rosinterface_handler::setParam(privateNamespace_ + "half_resolution",half_resolution);
    rosinterface_handler::setParam(privateNamespace_ + "method",method);
    rosinterface_handler::setParam(privateNamespace_ + "max_tracklength",max_tracklength);
  }

  /// \brief Update configurable parameters.
  ///
  /// \param config  dynamic reconfigure struct
  /// \level ?
  void fromConfig(const Config& config, const uint32_t level = 0){
#ifdef DYNAMIC_RECONFIGURE_FOUND

    if(config.verbosity != this->verbosity) {
        rosinterface_handler::setParam(privateNamespace_ + "verbosity", config.verbosity);
        rosinterface_handler::setLoggerLevel(privateNodeHandle_, "verbosity");
    }
    verbosity = config.verbosity;
    blur_size = config.blur_size;
    blur_sigma = config.blur_sigma;
    nms_n = config.nms_n;
    nms_tau = config.nms_tau;
    match_binsize = config.match_binsize;
    match_radius = config.match_radius;
    match_disp_tolerance = config.match_disp_tolerance;
    outlier_flow_tolerance = config.outlier_flow_tolerance;
    outlier_disp_tolerance = config.outlier_disp_tolerance;
    multi_stage = config.multi_stage;
    half_resolution = config.half_resolution;
    max_tracklength = config.max_tracklength;
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
  rosinterface_handler::exit("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
#endif
  }

  /// \brief Stream operator for printing parameter struct
  friend std::ostream& operator<<(std::ostream& os, const FeatureTrackingContourRoiInterface& p)
  {
    os << "[" << p.nodeName_ << "]\nNode " << p.nodeName_ << " has the following parameters:\n"
      << "	" << p.privateNamespace_ << "verbosity:" << p.verbosity << "\n"
      << "	" << p.privateNamespace_ << "msg_queue_size:" << p.msg_queue_size << "\n"
      << "	" << p.privateNamespace_ << "verbosity_debug:" << p.verbosity_debug << "\n"
      << "	" << p.privateNamespace_ << "verbosity_info:" << p.verbosity_info << "\n"
      << "	" << p.privateNamespace_ << "verbosity_warning:" << p.verbosity_warning << "\n"
      << "	" << p.privateNamespace_ << "verbosity_error:" << p.verbosity_error << "\n"
      << "	" << p.privateNamespace_ << "verbosity_fatal:" << p.verbosity_fatal << "\n"
      << "	" << p.privateNamespace_ << "subscriber_image:" << p.subscriber_image << "\n"
      << "	" << p.privateNamespace_ << "subscriber_contour:" << p.subscriber_contour << "\n"
      << "	" << p.privateNamespace_ << "publisher_msg_name:" << p.publisher_msg_name << "\n"
      << "	" << p.privateNamespace_ << "scale_factor:" << p.scale_factor << "\n"
      << "	" << p.privateNamespace_ << "blur_size:" << p.blur_size << "\n"
      << "	" << p.privateNamespace_ << "blur_sigma:" << p.blur_sigma << "\n"
      << "	" << p.privateNamespace_ << "nms_n:" << p.nms_n << "\n"
      << "	" << p.privateNamespace_ << "nms_tau:" << p.nms_tau << "\n"
      << "	" << p.privateNamespace_ << "match_binsize:" << p.match_binsize << "\n"
      << "	" << p.privateNamespace_ << "match_radius:" << p.match_radius << "\n"
      << "	" << p.privateNamespace_ << "match_disp_tolerance:" << p.match_disp_tolerance << "\n"
      << "	" << p.privateNamespace_ << "outlier_flow_tolerance:" << p.outlier_flow_tolerance << "\n"
      << "	" << p.privateNamespace_ << "outlier_disp_tolerance:" << p.outlier_disp_tolerance << "\n"
      << "	" << p.privateNamespace_ << "multi_stage:" << p.multi_stage << "\n"
      << "	" << p.privateNamespace_ << "half_resolution:" << p.half_resolution << "\n"
      << "	" << p.privateNamespace_ << "method:" << p.method << "\n"
      << "	" << p.privateNamespace_ << "max_tracklength:" << p.max_tracklength << "\n"
;
    return os;
  }

  /// \brief get the node handle that the interface struct uses internally
  ros::NodeHandle getPrivateNodeHandle() {
      return privateNodeHandle_;
  }

  /// \brief returns the name of the node (works in nodelets, too)
  const std::string& nodeName() const {
      return nodeName_;
  }

  /// \brief logs to the debug output. Works also within nodelets. Output is throttled.
  // NOLINTNEXTLINE(readability-function-size)
  inline void logDebug(const std::string& msg) const {
      ROS_DEBUG_STREAM_NAMED(nodeName(), msg);
  }

  /// \brief logs to the debug output. Works also within nodelets. Output is throttled.
  // NOLINTNEXTLINE(readability-function-size)
  inline void logInfo(const std::string& msg) const {
      ROS_INFO_STREAM_THROTTLE_NAMED(5, nodeName(), msg);
  }

  /// \brief logs to the debug output. Works also within nodelets. Output is throttled.
  // NOLINTNEXTLINE(readability-function-size)
  inline void logWarn(const std::string& msg) const {
      ROS_WARN_STREAM_THROTTLE_NAMED(5, nodeName(), msg);
  }

  /// \brief logs to the error output. Works also within nodelets. Output is throttled.
  // NOLINTNEXTLINE(readability-function-size)
  inline void logError(const std::string& msg) const {
      ROS_ERROR_STREAM_THROTTLE_NAMED(5, nodeName(), msg);
  }

  /// \brief logs to the error output. Works also within nodelets. Not throttled! Dont call this in loops!
  // NOLINTNEXTLINE(readability-function-size)
  inline void logErrorDirect(const std::string& msg) const {
      ROS_ERROR_STREAM_NAMED(nodeName(), msg);
  }
private:
  const std::string globalNamespace_;
  const std::string publicNamespace_;
  const std::string privateNamespace_;
  const std::string nodeName_;
  ros::NodeHandle privateNodeHandle_;

public:
  std::string verbosity; /*!< Sets the verbosity for this node */
  int msg_queue_size; /*!< Queuesize for publisher */
  static constexpr auto verbosity_debug = "debug"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_info = "info"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_warning = "warning"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_error = "error"; /*!< Constant for enum verbosity */
  static constexpr auto verbosity_fatal = "fatal"; /*!< Constant for enum verbosity */
  std::string subscriber_image; /*!< Topicname for image subscriber */
  std::string subscriber_contour; /*!< Topicname for contour subscriber */
  std::string publisher_msg_name; /*!< Topicname for publisher */
  double scale_factor; /*!< scaling factor for images for real_time_performance < 1. means image gets smaller */
  int blur_size; /*!< mask size of blurring */
  double blur_sigma; /*!< sigma of blurring */
  int nms_n; /*!< non-max-suppression: min. distance between maxima (in pixels) */
  int nms_tau; /*!< non-max-suppression: interest point peakiness threshold */
  int match_binsize; /*!< matching bin width/height (affects efficiency only) */
  int match_radius; /*!< matching radius (du/dv in pixels) */
  int match_disp_tolerance; /*!< dv tolerance for stereo matches (in pixels) */
  int outlier_flow_tolerance; /*!< outlier removal: flow tolerance (in pixels) */
  int outlier_disp_tolerance; /*!< outlier removal: disparity tolerance (in pixels) */
  int multi_stage; /*!<  0=disabled,1=multistage matching (denser and faster) */
  int half_resolution; /*!<  0=disabled,1=match at half resolution, refine at full resolution */
  int method; /*!<  matching method. Should be quad(2), stereo(1) or flow(0) */
  int max_tracklength; /*!< older detections of one feature than this age are discarded */



private:
  /// \brief Issue a warning about missing default parameters.
  void missingParamsWarning(){
    ROS_WARN_STREAM("[" << nodeName_ << "]\nThe following parameters do not have default values and need to be specified:\n"
    );
  }
};

} // namespace viso_feature_tracking_ros_tool
